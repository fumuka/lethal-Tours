<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>リーサル計算ツール</title>
  <style>
    body {
      font-family: 'Segoe UI', 'Meiryo', sans-serif;
      background: #f9f9f9;
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 420px;
      margin: 12px auto 24px auto;
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 3px 12px #0001;
      padding: 18px 10px 24px 10px;
    }
    h2 {
      font-size: 1.3em;
      text-align: center;
      margin: 0 0 16px 0;
      letter-spacing: 1px;
    }
    .inputs {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: space-between;
      margin-bottom: 14px;
    }
    .input-group {
      flex: 1 1 48%;
      display: flex;
      flex-direction: column;
      font-size: 1em;
    }
    .input-group label {
      font-size: .98em;
      margin-bottom: 2px;
      color: #444;
    }
    .input-group input, .input-group select {
      font-size: 1.07em;
      padding: 5px 6px;
      border: 1px solid #bbb;
      border-radius: 5px;
      background: #fafbfc;
    }
    .atco-section {
      margin: 14px 0;
      padding: 10px;
      background: #f0f4f8;
      border-radius: 5px;
      border: 1px solid #ccc;
    }
    .atco-title {
      font-size: 1.05em;
      font-weight: bold;
      margin-bottom: 8px;
      color: #333;
    }
    .atco-inputs {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .atco-input-group {
      flex: 1 1 48%;
      display: flex;
      flex-direction: column;
      font-size: 0.95em;
    }
    .atco-input-group label {
      font-size: 0.9em;
      margin-bottom: 2px;
      color: #555;
    }
    .atco-input-group input {
      font-size: 1em;
      padding: 4px 5px;
      border: 1px solid #bbb;
      border-radius: 4px;
      background: #fff;
    }
    .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    .row span {
      font-size: 1.13em;
      font-weight: bold;
    }
    .btns {
      display: flex;
      gap: 8px;
      margin: 14px 0 8px 0;
      justify-content: center;
    }
    button {
      flex: 1;
      background: #1976d2;
      color: #fff;
      border: none;
      border-radius: 7px;
      padding: 9px 0;
      font-size: 1.06em;
      font-weight: bold;
      cursor: pointer;
      transition: background .15s;
    }
    button:active {
      background: #13539c;
    }
    .history-title {
      margin: 19px 0 3px 0;
      font-size: 1.07em;
      font-weight: normal;
      border-bottom: 1px solid #ddd;
      padding-bottom: 2px;
      color: #222;
    }
    .history-list {
      background: #f7f7fd;
      border-radius: 5px;
      padding: 8px 5px 8px 8px;
      font-size: .99em;
      line-height: 1.5;
      max-height: 220px;
      overflow-y: auto;
      margin-bottom: 0;
    }
    .end-msg {
      margin-top: 12px;
      color: #e53935;
      font-weight: bold;
      font-size: 1.14em;
      text-align: center;
    }
    .debug {
      margin-top: 10px;
      padding: 8px;
      background: #e8f5e8;
      border-radius: 5px;
      font-size: 0.9em;
      color: #333;
    }
    @media (max-width: 450px) {
      .container { max-width: 97vw; padding: 9px 2vw 18px 2vw; }
      .inputs { gap: 6px; }
      button { font-size: 1em; padding: 8px 0; }
      .history-list { font-size: .98em; }
      .atco-input-group { flex: 1 1 100%; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>リーサル計算ツール</h2>
    <div class="inputs">
      <div class="input-group">
        <label for="xPower">合計パワー X</label>
        <input id="xPower" type="number" min="1" step="1" value="240000">
      </div>
      <div class="input-group">
        <label for="leaderPower">相手リーダーのパワー L</label>
        <input id="leaderPower" type="number" min="1" step="1" value="20000">
      </div>
      <div class="input-group">
        <label for="yAttack">総攻撃回数 Y</label>
        <input id="yAttack" type="number" min="1" step="1" value="4">
      </div>
      <div class="input-group">
        <label for="zNeed">必要攻撃回数 Z</label>
        <select id="zNeed">
          <option value="2">2</option>
          <option value="3" selected>3</option>
        </select>
      </div>
    </div>
    
    <div class="atco-section" id="atcoSection">
      <div class="atco-title">atco値設定</div>
      <div class="atco-inputs" id="atcoInputs">
        <!-- atco inputs will be dynamically generated -->
      </div>
    </div>
    
    <div class="row">
      <span>打点 A：</span>
      <span id="aDamage">-</span>
    </div>
    <div class="btns">
      <button id="calcBtn">計算</button>
      <button id="successBtn">攻撃が通った</button>
      <button id="failBtn">攻撃が守られた</button>
    </div>
    <div class="history-title">履歴</div>
    <div class="history-list" id="history"></div>
    <div class="debug" id="debug"></div>
    <div class="end-msg" id="endMsg"></div>
  </div>
  <script>
    // 初期値
    let X = 240000, L = 20000, Y = 4, Z = 3;
    let attackLeft = Y, attackNeed = Z, totalPower = X, leaderPower = L;
    let originalY = Y, originalZ = Z, originalX = X, originalL = L;
    let history = [];
    let ended = false;
    let atcoValues = [];
    let completedAttacks = 0;

    const $ = id => document.getElementById(id);
    const to5000Unit = v => Math.floor((v + 2499) / 5000) * 5000;

    // atco入力欄を動的に生成
    function generateAtcoInputs(restoreValues = []) {
      const atcoInputsContainer = $("atcoInputs");
      atcoInputsContainer.innerHTML = "";
      const atcoCount = Y - 2;
      if (atcoCount > 0) {
        for (let i = 0; i < atcoCount; i++) {
          const inputGroup = document.createElement("div");
          inputGroup.className = "atco-input-group";
          const label = document.createElement("label");
          label.textContent = `atco${i + 1}`;
          label.setAttribute("for", `atco${i + 1}`);
          const input = document.createElement("input");
          input.type = "number";
          input.id = `atco${i + 1}`;
          input.min = "0";
          input.step = "1";
          input.value = restoreValues[i] !== undefined ? restoreValues[i] : "0";
          input.addEventListener('input', () => {
            updateVars();
            let A = calcA(totalPower, leaderPower, attackLeft, attackNeed, originalY, originalZ, completedAttacks);
            showA(A);
            updateDebug();
          });
          input.addEventListener('change', () => {
            updateVars();
            let A = calcA(totalPower, leaderPower, attackLeft, attackNeed, originalY, originalZ, completedAttacks);
            showA(A);
            updateDebug();
          });
          inputGroup.appendChild(label);
          inputGroup.appendChild(input);
          atcoInputsContainer.appendChild(inputGroup);
        }
      } else {
        atcoInputsContainer.innerHTML = "<p style='margin: 0; color: #666;'>atco値は不要です (Y-2 ≤ 0)</p>";
      }
    }

    const updateVars = () => {
      X = parseInt($("xPower").value, 10) || 0;
      L = parseInt($("leaderPower").value, 10) || 0;
      Y = parseInt($("yAttack").value, 10) || 0;
      Z = parseInt($("zNeed").value, 10) || 0;
      atcoValues = [];
      for (let i = 0; i < Y - 2; i++) {
        const atcoInput = $(`atco${i + 1}`);
        if (atcoInput) {
          atcoValues.push(parseInt(atcoInput.value, 10) || 0);
        }
      }
    };

    function showA(value) {
      $("aDamage").textContent = value > 0 ? value : "-";
    }

    function updateDebug() {
      const N = originalY - attackLeft;
      let debugText = `完了攻撃数: ${completedAttacks}, N (originalY - attackLeft): ${N}, 残りZ: ${attackNeed}`;
      if (attackNeed === 1) {
        debugText += `, atco${N}以降の合計: ${atcoValues.slice(N-1 >= 0 ? N-1 : 0).reduce((sum, val) => sum + val, 0)}`;
      }
      $("debug").textContent = debugText;
    }

    function formatHistory() {
      if (!history.length) return "（まだ履歴はありません）";
      return history.map((h, i) =>
        `#${i+1} 攻撃: 打点A=${h.A} | 残りパワーX=${h.X} | 残り攻撃Y=${h.Y} | 残り必要Z=${h.Z} (${h.pass ? "通った" : h.pass===false ? "守られた" : h.note})`
      ).join("<br>");
    }

    function endCheck() {
      if (attackLeft <= 0) {
        $("endMsg").textContent = "攻撃回数終了！";
        ended = true;
        return true;
      }
      if (totalPower <= 0) {
        $("endMsg").textContent = "パワーが残っていません。";
        ended = true;
        return true;
      }
      if (attackNeed <= 0) {
        $("endMsg").textContent = "必要攻撃回数を達成！";
        ended = true;
        return true;
      }
      return false;
    }

    function splitPowerForZ(X, Z) {
      if (Z === 1) return [X];
      let values = [];
      let base = Math.floor(X / Z / 5000) * 5000;
      let totalBase = base * Z;
      let remain = X - totalBase;
      for (let i = 0; i < Z; i++) values.push(base);
      for (let i = Z - 1; i >= 0 && remain > 0; i--) {
        let add = Math.min(remain, 5000);
        values[i] += add;
        remain -= add;
      }
      if (X % 5000 !== 0 && Z >= 2) {
        let sum = values.reduce((a, b) => a + b, 0);
        let over = sum - X;
        if (over > 0) values[0] -= over;
      }
      return values;
    }

    function calculateAtcoSumZ2(completedAttacks, y, atcoVals) {
      let sum = 0;
      let yPrime = y;
      for (let i = completedAttacks; i < atcoVals.length && yPrime > 2; i++) {
        sum += (atcoVals[i] * (yPrime - 1)) / y;
        yPrime--;
      }
      return sum;
    }

    function calculateAtcoSumZ3(completedAttacks, y, atcoVals) {
      let sum = 0;
      for (let i = completedAttacks; i < y - 3 + completedAttacks && i < atcoVals.length; i++) {
        let base = atcoVals[i] / y;
        let extra = 0;
        if (y === 4) {
          extra = 0;
        } else if (y === 5) {
          if (i - completedAttacks === 1) {
            extra = base * (1 / 3);
          }
        } else if (y === 6) {
          if (i - completedAttacks === 1 || i - completedAttacks === 2) {
            extra = base * (2 / 4);
          }
        } else if (y === 7) {
          if (i - completedAttacks === 1) {
            extra = base * (3 / 5);
          } else if (i - completedAttacks === 2) {
            extra = base * (4 / 5);
          } else if (i - completedAttacks === 3) {
            extra = base * (3 / 5);
          }
        }
        sum += base + extra;
      }
      return sum;
    }

    function calcA(X, L, Y, Z, origY, origZ, completedAttacks = 0) {
      // Z=1時、atcoN-1以降の合計をXから引く
      if (Z === 1) {
        let N = origY - Y;
        let startIndex = N - 1;
        let remainingAtcoSum = 0;
        if (startIndex < 0) startIndex = 0;
        for (let i = startIndex; i < atcoValues.length; i++) {
          remainingAtcoSum += atcoValues[i];
        }
        return Math.max(0, X - remainingAtcoSum);
      }
      if (Z === Y && Z > 0) {
        const arr = splitPowerForZ(X, Z);
        return arr[0];
      }
      if (Z === 2 && Y > 2) {
        let l5 = L - 5000;
        let baseA = (X - l5 * ((Y - 2) * (Y - 1) / 2)) / Y + l5 * (Y - 2);
        let atcoSum = calculateAtcoSumZ2(completedAttacks, Y, atcoValues);
        let A = baseA - atcoSum;
        return to5000Unit(A);
      }
      if (Z === 3 && Y > 3) {
        let l5 = (L - 5000) / 3;
        let baseA = (X / Y) + (l5 / Y) * ((Y * Y - Y) / 2 - 3);
        let atcoSum = calculateAtcoSumZ3(completedAttacks, Y, atcoValues);
        let A = baseA - atcoSum;
        return to5000Unit(A);
      }
      return to5000Unit(X / Z);
    }

    function recalc(resetHistory = true, restoreAtco = true) {
      let savedAtco = [];
      if (restoreAtco) {
        for (let i = 0; i < atcoValues.length; i++) {
          savedAtco.push(atcoValues[i]);
        }
      }
      X = parseInt($("xPower").value, 10) || 0;
      L = parseInt($("leaderPower").value, 10) || 0;
      Y = parseInt($("yAttack").value, 10) || 0;
      Z = parseInt($("zNeed").value, 10) || 0;
      totalPower = X;
      leaderPower = L;
      attackLeft = Y;
      attackNeed = Z;
      originalY = Y;
      originalZ = Z;
      originalX = X;
      originalL = L;
      ended = false;
      $("endMsg").textContent = "";
      if (resetHistory) {
        history = [];
        completedAttacks = 0;
        generateAtcoInputs(savedAtco);
      }
      updateVars();
      let A = calcA(totalPower, leaderPower, attackLeft, attackNeed, originalY, originalZ, completedAttacks);
      showA(A);
      updateDebug();
      $("history").innerHTML = formatHistory();
    }

    function afterAttack(pass) {
      if (ended) return;
      let A = calcA(totalPower, leaderPower, attackLeft, attackNeed, originalY, originalZ, completedAttacks);
      if (attackNeed === attackLeft && attackLeft > 0) {
        let arr = splitPowerForZ(totalPower, attackNeed);
        for (let i = 0; i < attackNeed; i++) {
          history.push({A: arr[i], X: totalPower - arr.slice(0, i + 1).reduce((a, b) => a + b, 0), Y: attackLeft - i - 1, Z: attackNeed - i - 1, pass: pass, note: "均等割り"});
        }
        attackLeft = 0;
        totalPower = 0;
        attackNeed = 0;
        completedAttacks = originalY;
        showA("-");
        updateDebug();
        $("history").innerHTML = formatHistory();
        endCheck();
        return;
      }
      if (pass) {
        history.push({A, X: totalPower - A, Y: attackLeft - 1, Z: attackNeed - 1, pass: true});
        totalPower -= A;
        attackLeft -= 1;
        attackNeed -= 1;
        completedAttacks++;
        if (attackNeed > 0 && attackLeft > 0) {
          let nextA = calcA(totalPower, leaderPower, attackLeft, attackNeed, originalY, originalZ, completedAttacks);
          showA(nextA);
        } else {
          showA("-");
        }
      } else {
        history.push({A, X: totalPower - A, Y: attackLeft - 1, Z: attackNeed, pass: false});
        totalPower -= A;
        attackLeft -= 1;
        completedAttacks++;
        if (attackNeed === 2 && attackLeft > 1) {
          let nextA = calcA(totalPower, leaderPower, attackLeft, attackNeed, originalY, originalZ, completedAttacks);
          showA(nextA);
        } else if (attackNeed === 3 && attackLeft > 2) {
          let nextA = calcA(totalPower, leaderPower, attackLeft, attackNeed, originalY, originalZ, completedAttacks);
          showA(nextA);
        } else {
          showA("-");
        }
      }
      updateDebug();
      $("history").innerHTML = formatHistory();
      endCheck();
    }

    $("calcBtn").onclick = () => {
      recalc(true, true);
    };
    $("successBtn").onclick = () => afterAttack(true);
    $("failBtn").onclick = () => afterAttack(false);
    $("xPower").onchange = $("leaderPower").onchange = $("yAttack").onchange = $("zNeed").onchange = () => recalc(true, false);

    recalc(true, true);
  </script>
</body>
</html>